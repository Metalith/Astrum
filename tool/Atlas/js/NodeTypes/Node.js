// Generated by CoffeeScript 1.10.0
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(["react", "Actions"], function(React, Actions) {
  var Node, NodeField, OutputNode, TestNode, ValueNode, connect, mapSelectedToProps;
  connect = require('reactredux').connect;
  NodeField = (function(superClass) {
    extend(NodeField, superClass);

    function NodeField(props) {
      NodeField.__super__.constructor.call(this, props);
    }

    NodeField.prototype.render = function() {
      return React.createElement("div", {
        "className": "Field",
        "id": this.props.field,
        "ref": ((function(_this) {
          return function(c) {
            return _this.el = c;
          };
        })(this)),
        "onMouseDown": ((function(_this) {
          return function(e) {
            _this.el.classList.add('sel');
            _this.props.startConnection(_this.props.field, _this.props.type);
            return e.stopPropagation();
          };
        })(this)),
        "onMouseEnter": ((function(_this) {
          return function() {
            return _this.el.classList.add('hov');
          };
        })(this)),
        "onMouseLeave": ((function(_this) {
          return function() {
            return _this.el.classList.remove('hov');
          };
        })(this))
      }, this.props.field, React.createElement("div", {
        "className": "Handle"
      }));
    };

    return NodeField;

  })(React.Component);
  Node = (function(superClass) {
    extend(Node, superClass);

    Node.prototype.el = '';

    function Node(props) {
      this.update = bind(this.update, this);
      this.endConnection = bind(this.endConnection, this);
      this.startConnection = bind(this.startConnection, this);
      this.onMouseUp = bind(this.onMouseUp, this);
      this.onDrag = bind(this.onDrag, this);
      this.onMouseDown = bind(this.onMouseDown, this);
      this.componentWillUpdate = bind(this.componentWillUpdate, this);
      Node.__super__.constructor.call(this, props);
      this.state = {
        dragging: false,
        pos: {
          x: this.props.pos.x,
          y: this.props.pos.y
        },
        rel: null
      };
    }

    Node.prototype.output = {};

    Node.prototype.input = {};

    Node.prototype.componentWillUpdate = function(props, state) {
      if (!this.state.dragging && state.dragging) {
        document.addEventListener('mousemove', this.onDrag);
        return document.addEventListener('mouseup', this.onMouseUp);
      } else if (this.state.dragging && !state.dragging) {
        document.removeEventListener('mousemove', this.onDrag);
        return document.removeEventListener('mouseup', this.onMouseUp);
      }
    };

    Node.prototype.componentWillReceiveProps = function(nextProps) {
      return console.log(nextProps.Connections.length);
    };

    Node.prototype.onMouseDown = function(e) {
      if (e.target.tagName !== "INPUT" && e.target.className !== "Field" && e.target.className !== "Handle") {
        return this.setState({
          dragging: true,
          rel: {
            x: e.pageX - this.state.pos.x,
            y: e.pageY - this.state.pos.y
          }
        });
      }
    };

    Node.prototype.onDrag = function(e) {
      var Con, Connector, Handle1, Handle2, d, h, h1, h2, half, height, i, newPos, ref, t;
      newPos = {
        x: e.pageX - this.state.rel.x,
        y: e.pageY - this.state.rel.y
      };
      ref = this.props.Connections;
      for (i in ref) {
        Con = ref[i];
        Connector = document.querySelector("#Connector" + Con.id);
        h1 = document.querySelector("#Node" + Con.Node1.Node).getBoundingClientRect();
        h2 = document.querySelector("#Node" + Con.Node2.Node).getBoundingClientRect();
        Handle1 = {};
        Handle2 = {};
        if (Con.Node1.Node === this.props.id) {
          Handle1 = {
            x: e.pageX - this.state.rel.x + Con.Node1.HandlePos.x,
            y: e.pageY - this.state.rel.y + Con.Node1.HandlePos.y
          };
          Handle2 = {
            x: h2.left + Con.Node2.HandlePos.x,
            y: h2.top + Con.Node2.HandlePos.y
          };
        } else {
          Handle1 = {
            x: h1.left + Con.Node1.HandlePos.x,
            y: h1.top + Con.Node1.HandlePos.y
          };
          Handle2 = {
            x: e.pageX - this.state.rel.x + Con.Node2.HandlePos.x,
            y: e.pageY - this.state.rel.y + Con.Node2.HandlePos.y
          };
        }
        d = "M" + Handle1.x + " " + Handle1.y;
        d += "h-50";
        if (Handle1.x < Handle2.x + 100) {
          half = (Handle2.y - Handle1.y) / 2;
          height = 0;
          if (half >= 0) {
            height = h1.bottom - h2.top;
          } else {
            height = h2.bottom - h1.top;
          }
          if (height + 25 >= 0) {
            h = h1.height + h2.height + 25;
            t = 1;
            if (half < 0) {
              t = -1;
            }
            d += "v" + (t * h);
            d += "H" + (Handle2.x + 50);
            d += "v" + (t * (-h + (t * half) * 2));
            d += "h-50";
          } else {
            d += "v" + half;
            d += "H" + (Handle2.x + 50);
            d += "v" + half;
            d += "h-50";
          }
        } else {
          half = (Handle2.x - Handle1.x) / 2 + 50;
          d += "h" + half;
          d += "V" + Handle2.y;
          d += "h" + half;
          d += "h-50";
        }
        Connector.setAttribute("d", d);
      }
      return this.setState({
        pos: newPos
      });
    };

    Node.prototype.onMouseUp = function(e) {
      this.setState({
        dragging: false
      });
      return this.props.dispatch(Actions.setPos(this.props.id, this.state.pos));
    };

    Node.prototype.startConnection = function(field, type) {
      var handlePos, handleRect;
      handleRect = document.querySelector("#Node" + this.props.id + ">." + type + ">#" + field + ">.Handle").getBoundingClientRect();
      handlePos = {
        x: handleRect.left + handleRect.width / 2 - this.state.pos.x,
        y: handleRect.top + handleRect.height / 2 - this.state.pos.y
      };
      if (type === "Output") {
        this.props.dispatch(Actions.startConnecting(this.props.id, field, type, handlePos, this.output[field]));
      } else {
        this.props.dispatch(Actions.startConnecting(this.props.id, field, type, handlePos, 0));
      }
      return document.addEventListener('mouseup', this.endConnection);
    };

    Node.prototype.endConnection = function(e) {
      var handlePos, handleRect;
      this.props.dispatch(Actions.stopConnecting());
      if (e.target.classList.contains("Field")) {
        if (e.target.parentElement.className !== this.props.Selected.Type) {
          if (e.target.parentElement.parentElement.id !== "Node" + this.props.Selected.Node) {
            handleRect = e.target.querySelector('.Handle').getBoundingClientRect();
            handlePos = {
              x: handleRect.left + handleRect.width / 2 - e.target.parentElement.parentElement.offsetLeft,
              y: handleRect.top + handleRect.height / 2 - e.target.parentElement.parentElement.offsetTop
            };
            if (this.props.Selected.Type === "Input") {
              this.props.dispatch(Actions.addConnection(this.props.Selected, {
                Node: parseInt(e.target.parentElement.parentElement.id.replace(/^\D+/g, '')),
                Field: e.target.textContent,
                Type: e.target.parentElement.className,
                HandlePos: handlePos
              }));
            } else {
              this.props.dispatch(Actions.addConnection({
                Node: parseInt(e.target.parentElement.parentElement.id.replace(/^\D+/g, '')),
                Field: e.target.textContent,
                Type: e.target.parentElement.className,
                HandlePos: handlePos
              }, this.props.Selected));
            }
          } else {
            alert("Error: Cannot connect a node to itself");
          }
        } else {
          alert("Error: Fields of same type");
        }
      }
      return document.removeEventListener('mouseup', this.endConnection);
    };

    Node.prototype.update = function() {};

    Node.prototype.render = function() {
      var Center, Input, Output, i, k, v;
      i = 0;
      Input = React.createElement("div", {
        "className": "Input"
      }, React.createElement("br", null), (function() {
        var ref, results;
        ref = this.input;
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push(React.createElement(NodeField, {
            "key": ++i,
            "field": k,
            "type": "Input",
            "startConnection": this.startConnection
          }));
        }
        return results;
      }).call(this));
      Center = React.createElement("div", {
        "className": "Center"
      }, React.createElement("div", {
        "className": "NodeName"
      }, this.name), React.createElement("div", {
        "className": "Values"
      }, this.center()));
      Output = React.createElement("div", {
        "className": "Output"
      }, React.createElement("br", null), (function() {
        var ref, results;
        ref = this.output;
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push(React.createElement(NodeField, {
            "key": ++i,
            "field": k,
            "type": "Output",
            "startConnection": this.startConnection
          }));
        }
        return results;
      }).call(this));
      return React.createElement("div", {
        "className": "Node",
        "id": "Node" + this.props.id,
        "style": {
          position: "absolute",
          left: this.state.pos.x,
          top: this.state.pos.y
        },
        "onMouseDown": this.onMouseDown
      }, Input, Center, Output);
    };

    return Node;

  })(React.Component);
  TestNode = (function(superClass) {
    extend(TestNode, superClass);

    TestNode.prototype.name = 'Test Node';

    function TestNode(props) {
      TestNode.__super__.constructor.call(this, props);
    }

    TestNode.prototype.input = {
      TestInput: "Test"
    };

    TestNode.prototype.center = function() {
      return React.createElement("input", {
        "type": "number",
        "name": "fname",
        "onChange": this.update
      });
    };

    return TestNode;

  })(Node);
  ValueNode = (function(superClass) {
    extend(ValueNode, superClass);

    ValueNode.prototype.name = 'Value';

    function ValueNode(props) {
      this.update = bind(this.update, this);
      ValueNode.__super__.constructor.call(this, props);
    }

    ValueNode.prototype.update = function(e) {
      this.output.Val = parseInt(e.target.value);
      return ValueNode.__super__.update.call(this);
    };

    ValueNode.prototype.center = function() {
      return React.createElement("input", {
        "type": "number",
        "name": "fname",
        "onChange": this.update
      });
    };

    ValueNode.prototype.output = {
      Val: 2
    };

    return ValueNode;

  })(Node);
  OutputNode = (function(superClass) {
    extend(OutputNode, superClass);

    OutputNode.prototype.name = 'Output';

    function OutputNode(props) {
      OutputNode.__super__.constructor.call(this, props);
    }

    OutputNode.prototype.center = function() {
      return "";
    };

    OutputNode.prototype.input = {
      Program: ""
    };

    return OutputNode;

  })(Node);
  mapSelectedToProps = (function(_this) {
    return function(state) {
      return {
        Selected: state.Selected
      };
    };
  })(this);
  return {
    TestNode: connect(mapSelectedToProps)(TestNode),
    Value: connect(mapSelectedToProps)(ValueNode),
    Output: connect(mapSelectedToProps)(OutputNode)
  };
});

//# sourceMappingURL=Node.map
