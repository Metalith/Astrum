// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(["react"], function(React) {
    var Connector, connect, mapStateToProps;
    connect = require('reactredux').connect;
    Connector = (function(superClass) {
      extend(Connector, superClass);

      Connector.prototype.d = 'M150 150 L0 0';

      function Connector(props) {
        this.updateD = bind(this.updateD, this);
        this.componentWillUpdate = bind(this.componentWillUpdate, this);
        Connector.__super__.constructor.call(this, props);
        this.state = {
          update: true
        };
      }

      Connector.prototype.componentWillUpdate = function(nextProps, nextState) {
        if ((!this.props.Input.dragging && nextProps.Input.dragging) || (!this.props.Output.dragging && nextProps.Output.dragging)) {
          return document.addEventListener('mousemove', this.updateD);
        } else if (this.props.Input.dragging && !nextProps.Input.dragging) {
          return document.removeEventListener('mousemove', this.updateD) || (this.props.Output.dragging && !nextProps.Output.dragging);
        }
      };

      Connector.prototype.componentWillMount = function() {
        return this.updateD();
      };

      Connector.prototype.updateD = function() {
        var InHandle, InHandleRect, OutHandle, OutHandleRect, h, h1, h2, half, height, t;
        InHandleRect = document.querySelector('#Node' + this.props.Connection.Input.Node + '>.Input>#' + this.props.Connection.Input.Field + '>.Handle').getBoundingClientRect();
        OutHandleRect = document.querySelector('#Node' + this.props.Connection.Output.Node + '>.Output>#' + this.props.Connection.Output.Field + '>.Handle').getBoundingClientRect();
        InHandle = {
          x: InHandleRect.left + InHandleRect.width / 2,
          y: InHandleRect.top + InHandleRect.height / 2
        };
        OutHandle = {
          x: OutHandleRect.left + OutHandleRect.width / 2,
          y: OutHandleRect.top + OutHandleRect.height / 2
        };
        this.d = "M" + InHandle.x + " " + InHandle.y;
        this.d += "h-50";
        if (InHandle.x < OutHandle.x + 100) {
          half = (OutHandle.y - InHandle.y) / 2;
          h1 = document.querySelector("#Node" + this.props.Connection.Input.Node).getBoundingClientRect();
          h2 = document.querySelector("#Node" + this.props.Connection.Output.Node).getBoundingClientRect();
          height = 0;
          if (half >= 0) {
            height = h1.bottom - h2.top;
          } else {
            height = h2.bottom - h1.top;
          }
          if (height + 25 >= 0) {
            h = h1.height + h2.height + 25;
            t = 1;
            if (half < 0) {
              t = -1;
            }
            this.d += "v" + (t * h);
            this.d += "H" + (OutHandle.x + 50);
            this.d += "v" + (t * (-h + (t * half) * 2));
            this.d += "h-50";
          } else {
            this.d += "v" + half;
            this.d += "H" + (OutHandle.x + 50);
            this.d += "v" + half;
            this.d += "h-50";
          }
        } else {
          half = (OutHandle.x - InHandle.x) / 2 + 50;
          this.d += "h" + half;
          this.d += "V" + OutHandle.y;
          this.d += "h" + half;
          this.d += "h-50";
        }
        return this.setState(this.state);
      };

      Connector.prototype.render = function() {
        return React.createElement("path", {
          "d": this.d,
          "stroke": "white",
          "strokeWidth": "2",
          "fill": "none"
        });
      };

      return Connector;

    })(React.Component);
    mapStateToProps = (function(_this) {
      return function(state, ownProps) {
        return {
          Input: state.Nodes[ownProps.Connection.Input.Node],
          Output: state.Nodes[ownProps.Connection.Output.Node]
        };
      };
    })(this);
    return connect(mapStateToProps)(Connector);
  });

}).call(this);

//# sourceMappingURL=Connector.map
