!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ApproximateZeroCrossingPosition	dc/octree.cpp	/^vec3 ApproximateZeroCrossingPosition(const vec3& p0, const vec3& p1) {$/;"	f
CHUNKMANAGER_HPP	systems/ChunkManager.hpp	2;"	d
CHUNK_HPP	systems/chunk.hpp	2;"	d
CHUNK_SIZE	systems/chunk.hpp	/^		static const int CHUNK_SIZE = 32;$/;"	m	class:Chunk
CONTROLS_HPP	common/controls.hpp	2;"	d
CalculateSurfaceNormal	dc/octree.cpp	/^vec3 CalculateSurfaceNormal(const vec3& p) {$/;"	f
Chunk	systems/chunk.cpp	/^Chunk::Chunk(int x, int y, int z, float LOD) {$/;"	f	class:Chunk
Chunk	systems/chunk.hpp	/^class Chunk {$/;"	c
ChunkList	main.cpp	/^std::vector<Chunk*> ChunkList;$/;"	v
ChunkList	systems/ChunkManager.cpp	/^std::vector<Chunk*> ChunkManager::ChunkList;$/;"	m	class:ChunkManager	file:
ChunkList	systems/ChunkManager.hpp	/^		static std::vector<Chunk*> ChunkList;$/;"	m	class:ChunkManager
ChunkList	systems/chunk.hpp	/^		static std::vector<Chunk*> ChunkList;$/;"	m	class:Chunk
ChunkManager	systems/ChunkManager.cpp	/^ChunkManager::ChunkManager(std::vector<GLfloat>& vertices, std::vector<GLfloat>& normals, std::vector<int>& indices, std::vector<GLfloat>& bounds){$/;"	f	class:ChunkManager
ChunkManager	systems/ChunkManager.hpp	/^class ChunkManager {$/;"	c
ContourCellProc	dc/octree.cpp	/^void ContourCellProc(Octree* node, std::vector<int>& indexBuffer)$/;"	f
ContourEdgeProc	dc/octree.cpp	/^void ContourEdgeProc(Octree* node[4], int dir, std::vector<int>& indexBuffer)$/;"	f
ContourFaceProc	dc/octree.cpp	/^void ContourFaceProc(Octree* node[2], int dir, std::vector<int>& indexBuffer)$/;"	f
ContourProcessEdge	dc/octree.cpp	/^void ContourProcessEdge(Octree* node[4], int dir, std::vector<int>& indexBuffer)$/;"	f
CreateWindow	main.cpp	/^bool CreateWindow() {$/;"	f
Draw	main.cpp	/^void Draw() {$/;"	f
Engine	engine.cpp	/^Engine::Engine() {}$/;"	f	class:Engine
Engine	engine.hpp	/^class Engine {$/;"	c
FilterNodesFunc	systems/chunk.cpp	/^typedef std::function<bool(const ivec3&, const ivec3&)> FilterNodesFunc;$/;"	t	file:
FilterNodesFunc	systems/chunk.hpp	/^		typedef std::function<bool(const ivec3&, const ivec3&)> FilterNodesFunc;$/;"	t	class:Chunk
FindNodesFunc	dc/octree.hpp	/^typedef std::function<bool(const ivec3&, const ivec3&)> FindNodesFunc;$/;"	t
GenerateBoundsFromOctree	dc/octree.cpp	/^void GenerateBoundsFromOctree(Octree* node, std::vector<GLfloat>& vertexBuffer)$/;"	f
GenerateMeshFromOctree	dc/octree.cpp	/^void GenerateMeshFromOctree(Octree* node, std::vector<GLfloat>& vertexBuffer, std::vector<GLfloat>& normalBuffer, std::vector<int>& indexBuffer)$/;"	f
GenerateVertex	dc/octree.cpp	/^bool Octree::GenerateVertex() {$/;"	f	class:Octree
GenerateVertexIndices	dc/octree.cpp	/^void GenerateVertexIndices(Octree* node, std::vector<GLfloat>& vertexBuffer, std::vector<GLfloat>& normalBuffer)$/;"	f
Givens	dc/svd.h	/^    class Givens$/;"	c	namespace:svd
LUNA_ENGINE_H	engine.hpp	2;"	d
LeastSquares	dc/svd.h	/^    class LeastSquares$/;"	c	namespace:svd
LoadShaders	common/shader.cpp	/^GLuint LoadShaders(const std::string& vertex_file_path,const std::string& fragment_file_path){$/;"	f
MATERIAL_AIR	dc/octree.cpp	/^const int MATERIAL_AIR = 0;$/;"	v
MATERIAL_SOLID	dc/octree.cpp	/^const int MATERIAL_SOLID = 1;$/;"	v
Mat3	dc/svd.cpp	/^    Mat3::Mat3()$/;"	f	class:svd::Mat3
Mat3	dc/svd.cpp	/^    Mat3::Mat3(const Mat3 &rhs)$/;"	f	class:svd::Mat3
Mat3	dc/svd.cpp	/^    Mat3::Mat3(const float m00, const float m01, const float m02,$/;"	f	class:svd::Mat3
Mat3	dc/svd.h	/^    class Mat3$/;"	c	namespace:svd
MatUtils	dc/svd.h	/^    class MatUtils$/;"	c	namespace:svd
Node_Internal	dc/octree.hpp	/^	Node_Internal,$/;"	e	enum:OctreeNodeType
Node_Leaf	dc/octree.hpp	/^	Node_Leaf,$/;"	e	enum:OctreeNodeType
Node_None	dc/octree.hpp	/^	Node_None,$/;"	e	enum:OctreeNodeType
Node_Psuedo	dc/octree.hpp	/^	Node_Psuedo,$/;"	e	enum:OctreeNodeType
OCTREE_HPP	dc/octree.hpp	2;"	d
OFFSETS	systems/ChunkManager.cpp	/^const ivec3 OFFSETS[8] =$/;"	v
Octree	dc/octree.cpp	/^Octree::Octree() {$/;"	f	class:Octree
Octree	dc/octree.cpp	/^Octree::Octree(vec3 position, float size, float LOD) {$/;"	f	class:Octree
Octree	dc/octree.cpp	/^Octree::Octree(vec3 position, std::vector<Octree*>& nodes,  float size) {$/;"	f	class:Octree
Octree	dc/octree.hpp	/^class Octree {$/;"	c
OctreeList	main.cpp	/^std::vector<Octree> OctreeList;$/;"	v
OctreeNodeType	dc/octree.hpp	/^enum OctreeNodeType$/;"	g
Octree_FindNodes	dc/octree.cpp	/^void Octree_FindNodes(Octree* node, FindNodesFunc& func, std::vector<Octree*>& nodes)$/;"	f
POINTS	common/controls.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	e	enum:__anon1	file:
POINTS	main.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	e	enum:__anon2	file:
ProjectionMatrix	common/controls.cpp	/^glm::mat4 ProjectionMatrix;$/;"	v
QEF_ERROR	dc/octree.cpp	/^const float QEF_ERROR = 1e-6f;$/;"	v
QEF_H	dc/qef.h	28;"	d
QEF_SWEEPS	dc/octree.cpp	/^const int QEF_SWEEPS = 4;$/;"	v
QefData	dc/qef.cpp	/^    QefData::QefData()$/;"	f	class:svd::QefData
QefData	dc/qef.cpp	/^    QefData::QefData(const QefData &rhs)$/;"	f	class:svd::QefData
QefData	dc/qef.cpp	/^    QefData::QefData(const float ata_00, const float ata_01,$/;"	f	class:svd::QefData
QefData	dc/qef.h	/^    class QefData$/;"	c	namespace:svd
QefSolver	dc/qef.cpp	/^    QefSolver::QefSolver() : data(), ata(), atb(), massPoint(), x(),$/;"	f	class:svd::QefSolver
QefSolver	dc/qef.h	/^    class QefSolver$/;"	c	namespace:svd
SDF	dc/octree.cpp	/^float SDF(vec3 p) { return testModule.GetValue(p.x \/ Chunk::CHUNK_SIZE, 0.0, p.z \/ Chunk::CHUNK_SIZE) + (2 * p.y\/Chunk::CHUNK_SIZE); }$/;"	f
SHADED	common/controls.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	e	enum:__anon1	file:
SHADED	main.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	e	enum:__anon2	file:
SHADER_HPP	common/shader.hpp	2;"	d
SIZE	main.cpp	/^int SIZE = 4;$/;"	v
SMat3	dc/svd.cpp	/^    SMat3::SMat3()$/;"	f	class:svd::SMat3
SMat3	dc/svd.cpp	/^    SMat3::SMat3(const SMat3 &rhs)$/;"	f	class:svd::SMat3
SMat3	dc/svd.cpp	/^    SMat3::SMat3(const float m00, const float m01, const float m02,$/;"	f	class:svd::SMat3
SMat3	dc/svd.h	/^    class SMat3$/;"	c	namespace:svd
SVD_H	dc/svd.h	28;"	d
Schur2	dc/svd.h	/^    class Schur2$/;"	c	namespace:svd
Svd	dc/svd.h	/^    class Svd$/;"	c	namespace:svd
UpdateVersion	main.cpp	/^std::string UpdateVersion() {$/;"	f
Vec3	dc/svd.cpp	/^    Vec3::Vec3() : x(0), y(0), z(0) { }$/;"	f	class:svd::Vec3
Vec3	dc/svd.cpp	/^    Vec3::Vec3(const Vec3 &rhs)\/\/ : Vec3()$/;"	f	class:svd::Vec3
Vec3	dc/svd.cpp	/^    Vec3::Vec3(const float x, const float y, const float z)\/\/ : Vec3()$/;"	f	class:svd::Vec3
Vec3	dc/svd.h	/^    class Vec3$/;"	c	namespace:svd
VecUtils	dc/svd.h	/^    class VecUtils$/;"	c	namespace:svd
Vertex	dc/octree.hpp	/^	Vertex(): index(-1), corners(0), position(10,10,10) {}$/;"	f	struct:Vertex
Vertex	dc/octree.hpp	/^	Vertex(Vertex const& v): index(v.index), corners(v.corners), position(vec3(v.position.x, v.position.y, v.position.z)), qef(v.qef), averageNormal(v.averageNormal) {}$/;"	f	struct:Vertex
Vertex	dc/octree.hpp	/^	Vertex(vec3 p): index(-1), corners(0), position(p) {}$/;"	f	struct:Vertex
Vertex	dc/octree.hpp	/^struct Vertex {$/;"	s
WIREFRAME	common/controls.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	e	enum:__anon1	file:
WIREFRAME	main.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	e	enum:__anon2	file:
add	dc/qef.cpp	/^    void QefData::add(const QefData &rhs)$/;"	f	class:svd::QefData
add	dc/qef.cpp	/^    void QefSolver::add(const QefData &rhs)$/;"	f	class:svd::QefSolver
add	dc/qef.cpp	/^    void QefSolver::add(const Vec3 &p, const Vec3 &n)$/;"	f	class:svd::QefSolver
add	dc/qef.cpp	/^    void QefSolver::add(const float px, const float py, const float pz,$/;"	f	class:svd::QefSolver
addScaled	dc/svd.cpp	/^    void VecUtils::addScaled(Vec3 &v, const float s, const Vec3 &rhs)$/;"	f	class:svd::VecUtils
addSystem	engine.cpp	/^void Engine::addSystem(System sys) {$/;"	f	class:Engine
ata	dc/qef.h	/^        SMat3 ata;$/;"	m	class:svd::QefSolver
ata_00	dc/qef.h	/^        float ata_00, ata_01, ata_02, ata_11, ata_12, ata_22;$/;"	m	class:svd::QefData
ata_01	dc/qef.h	/^        float ata_00, ata_01, ata_02, ata_11, ata_12, ata_22;$/;"	m	class:svd::QefData
ata_02	dc/qef.h	/^        float ata_00, ata_01, ata_02, ata_11, ata_12, ata_22;$/;"	m	class:svd::QefData
ata_11	dc/qef.h	/^        float ata_00, ata_01, ata_02, ata_11, ata_12, ata_22;$/;"	m	class:svd::QefData
ata_12	dc/qef.h	/^        float ata_00, ata_01, ata_02, ata_11, ata_12, ata_22;$/;"	m	class:svd::QefData
ata_22	dc/qef.h	/^        float ata_00, ata_01, ata_02, ata_11, ata_12, ata_22;$/;"	m	class:svd::QefData
atb	dc/qef.h	/^        Vec3 atb, massPoint, x;$/;"	m	class:svd::QefSolver
atb_x	dc/qef.h	/^        float atb_x, atb_y, atb_z;$/;"	m	class:svd::QefData
atb_y	dc/qef.h	/^        float atb_x, atb_y, atb_z;$/;"	m	class:svd::QefData
atb_z	dc/qef.h	/^        float atb_x, atb_y, atb_z;$/;"	m	class:svd::QefData
averageNormal	dc/octree.hpp	/^	vec3			averageNormal;$/;"	m	struct:Vertex
bar	main.cpp	/^TwBar *bar;$/;"	v
bounds	main.cpp	/^std::vector<GLfloat> bounds;$/;"	v
bounds	systems/ChunkManager.cpp	/^std::vector<GLfloat> *ChunkManager::bounds;$/;"	m	class:ChunkManager	file:
bounds	systems/ChunkManager.hpp	/^		static std::vector<GLfloat> *bounds;$/;"	m	class:ChunkManager
btb	dc/qef.h	/^        float btb;$/;"	m	class:svd::QefData
calcError	dc/svd.cpp	/^    static float calcError(const Mat3 &A, const Vec3 &x,$/;"	f	namespace:svd
calcError	dc/svd.cpp	/^    static float calcError(const SMat3 &origA, const Vec3 &x,$/;"	f	namespace:svd
calcSymmetricGivensCoefficients	dc/svd.cpp	/^    static void calcSymmetricGivensCoefficients(const float a_pp,$/;"	f	namespace:svd
cellProcEdgeMask	dc/octree.cpp	/^const int cellProcEdgeMask[6][5] = {{0,1,2,3,0},{4,5,6,7,0},{0,4,1,5,1},{2,6,3,7,1},{0,2,4,6,2},{1,3,5,7,2}} ;$/;"	v
cellProcFaceMask	dc/octree.cpp	/^const int cellProcFaceMask[12][3] = {{0,4,0},{1,5,0},{2,6,0},{3,7,0},{0,2,1},{4,6,1},{1,3,1},{5,7,1},{0,1,2},{2,3,2},{4,5,2},{6,7,2}} ;$/;"	v
centered	common/controls.cpp	/^char centered = 0;$/;"	v
clear	dc/qef.cpp	/^    void QefData::clear()$/;"	f	class:svd::QefData
clear	dc/svd.cpp	/^    void Mat3::clear()$/;"	f	class:svd::Mat3
clear	dc/svd.cpp	/^    void SMat3::clear()$/;"	f	class:svd::SMat3
clear	dc/svd.cpp	/^    void Vec3::clear()$/;"	f	class:svd::Vec3
cm	main.cpp	/^ChunkManager cm = ChunkManager(vertices, normals, indices, bounds);$/;"	v
computeMatricesFromInputs	common/controls.cpp	/^void computeMatricesFromInputs(){$/;"	f
corners	dc/octree.hpp	/^	char			corners;$/;"	m	struct:Vertex
createChunk	systems/ChunkManager.cpp	/^void ChunkManager::createChunk(int x, int y, int z) {$/;"	f	class:ChunkManager
data	dc/qef.h	/^        QefData data;$/;"	m	class:svd::QefSolver
displayModes	common/controls.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	t	typeref:enum:__anon1	file:
displayModes	main.cpp	/^typedef enum { SHADED, WIREFRAME, POINTS } displayModes;$/;"	t	typeref:enum:__anon2	file:
dot	dc/svd.cpp	/^    float VecUtils::dot(const Vec3 &a, const Vec3 &b)$/;"	f	class:svd::VecUtils
edgeProcEdgeMask	dc/octree.cpp	/^const int edgeProcEdgeMask[3][2][5] = {$/;"	v
edgemask	dc/octree.cpp	/^const int edgemask[3] = { 5, 3, 6 } ;$/;"	v
edgevmap	dc/octree.cpp	/^const int edgevmap[12][2] =$/;"	v
faceMap	dc/octree.cpp	/^const int faceMap[6][4] = {{4, 8, 5, 9}, {6, 10, 7, 11},{0, 8, 1, 10},{2, 9, 3, 11},{0, 4, 2, 6},{1, 5, 3, 7}} ;$/;"	v
faceProcEdgeMask	dc/octree.cpp	/^const int faceProcEdgeMask[3][4][6] = {$/;"	v
faceProcFaceMask	dc/octree.cpp	/^const int faceProcFaceMask[3][4][3] = {$/;"	v
findNodes	systems/chunk.cpp	/^std::vector<Octree*> Chunk::findNodes(FilterNodesFunc filterFunc)$/;"	f	class:Chunk
fnorm	dc/svd.cpp	/^    float MatUtils::fnorm(const Mat3 &a)$/;"	f	class:svd::MatUtils
fnorm	dc/svd.cpp	/^    float MatUtils::fnorm(const SMat3 &a)$/;"	f	class:svd::MatUtils
generate	systems/ChunkManager.cpp	/^void ChunkManager::generate(int x, int y, int z) {$/;"	f	class:ChunkManager
generateBounds	systems/chunk.cpp	/^void Chunk::generateBounds(std::vector<GLfloat>& vertexBuffer) {$/;"	f	class:Chunk
generateMesh	systems/chunk.cpp	/^void Chunk::generateMesh(std::vector<GLfloat>& vertexBuffer, std::vector<GLfloat>& normalBuffer, std::vector<int>& indexBuffer) {$/;"	f	class:Chunk
generateSeam	systems/chunk.cpp	/^void Chunk::generateSeam() {$/;"	f	class:Chunk
generateSeamMesh	systems/chunk.cpp	/^void Chunk::generateSeamMesh(std::vector<GLfloat>& vertexBuffer, std::vector<GLfloat>& normalBuffer, std::vector<int>& indexBuffer) {$/;"	f	class:Chunk
getChunk	systems/chunk.cpp	/^Chunk* Chunk::getChunk(vec3 position) {$/;"	f	class:Chunk
getData	dc/qef.cpp	/^	QefData QefSolver::getData()$/;"	f	class:svd::QefSolver
getError	dc/qef.cpp	/^    float QefSolver::getError()$/;"	f	class:svd::QefSolver
getError	dc/qef.cpp	/^    float QefSolver::getError(const Vec3 &pos)$/;"	f	class:svd::QefSolver
getMassPoint	dc/qef.h	/^		const Vec3& getMassPoint() const { return massPoint; }$/;"	f	class:svd::QefSolver
getPosition	common/controls.cpp	/^glm::vec3 getPosition()			{	return position;		}$/;"	f
getProjectionMatrix	common/controls.cpp	/^glm::mat4 getProjectionMatrix() {	return ProjectionMatrix;}$/;"	f
getSymmetricSvd	dc/svd.cpp	/^    void Svd::getSymmetricSvd(const SMat3 &a, SMat3 &vtav, Mat3 &v,$/;"	f	class:svd::Svd
getViewMatrix	common/controls.cpp	/^glm::mat4 getViewMatrix()		{	return ViewMatrix;		}$/;"	f
hasChildren	dc/octree.hpp	/^		bool hasChildren = false;$/;"	m	class:Octree
hasNewChunks	systems/ChunkManager.cpp	/^bool ChunkManager::hasNewChunks() {$/;"	f	class:ChunkManager
hasSolution	dc/qef.h	/^        bool hasSolution;$/;"	m	class:svd::QefSolver
horizontalAngle	common/controls.cpp	/^float horizontalAngle = 0.0f;$/;"	v
index	dc/octree.hpp	/^	int				index;$/;"	m	struct:Vertex
indices	main.cpp	/^std::vector<int> indices;$/;"	v
indices	systems/ChunkManager.cpp	/^std::vector<int>	 *ChunkManager::indices;$/;"	m	class:ChunkManager	file:
indices	systems/ChunkManager.hpp	/^		static std::vector<int>		*indices;$/;"	m	class:ChunkManager
initialFoV	common/controls.cpp	/^float initialFoV = 45.0f;$/;"	v
key_callback	common/controls.cpp	/^void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)$/;"	f
lookAtOrigin	common/controls.cpp	/^void lookAtOrigin() {$/;"	f
m00	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m00	dc/svd.h	/^        float m00, m01, m02, m11, m12, m22;$/;"	m	class:svd::SMat3
m01	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m01	dc/svd.h	/^        float m00, m01, m02, m11, m12, m22;$/;"	m	class:svd::SMat3
m02	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m02	dc/svd.h	/^        float m00, m01, m02, m11, m12, m22;$/;"	m	class:svd::SMat3
m10	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m11	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m11	dc/svd.h	/^        float m00, m01, m02, m11, m12, m22;$/;"	m	class:svd::SMat3
m12	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m12	dc/svd.h	/^        float m00, m01, m02, m11, m12, m22;$/;"	m	class:svd::SMat3
m20	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m21	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m22	dc/svd.h	/^        float m00, m01, m02, m10, m11, m12, m20, m21, m22;$/;"	m	class:svd::Mat3
m22	dc/svd.h	/^        float m00, m01, m02, m11, m12, m22;$/;"	m	class:svd::SMat3
m_SystemList	engine.hpp	/^		std::vector<System*> m_SystemList;$/;"	m	class:Engine
main	main.cpp	/^int main() {$/;"	f
massPoint	dc/qef.h	/^        Vec3 atb, massPoint, x;$/;"	m	class:svd::QefSolver
massPoint_x	dc/qef.h	/^        float massPoint_x, massPoint_y, massPoint_z;$/;"	m	class:svd::QefData
massPoint_y	dc/qef.h	/^        float massPoint_x, massPoint_y, massPoint_z;$/;"	m	class:svd::QefData
massPoint_z	dc/qef.h	/^        float massPoint_x, massPoint_y, massPoint_z;$/;"	m	class:svd::QefData
mmul	dc/svd.cpp	/^    void MatUtils::mmul(Mat3 &out, const Mat3 &a, const Mat3 &b)$/;"	f	class:svd::MatUtils
mmul_ata	dc/svd.cpp	/^    void MatUtils::mmul_ata(SMat3 &out, const Mat3 &a)$/;"	f	class:svd::MatUtils
mode	main.cpp	/^displayModes mode = SHADED;$/;"	v
mouseSpeed	common/controls.cpp	/^float mouseSpeed = 0.005f;$/;"	v
mutex	systems/ChunkManager.cpp	/^std::mutex ChunkManager::mutex;$/;"	m	class:ChunkManager	file:
mutex	systems/ChunkManager.hpp	/^		static std::mutex mutex;$/;"	m	class:ChunkManager
newChunks	systems/ChunkManager.cpp	/^bool ChunkManager::newChunks;$/;"	m	class:ChunkManager	file:
newChunks	systems/ChunkManager.hpp	/^		static bool newChunks;$/;"	m	class:ChunkManager
normalize	dc/qef.cpp	/^    static void normalize(float &nx, float &ny, float &nz)$/;"	f	namespace:svd
normalize	dc/svd.cpp	/^    void VecUtils::normalize(Vec3 &v)$/;"	f	class:svd::VecUtils
normals	main.cpp	/^std::vector<GLfloat> normals;$/;"	v
normals	systems/ChunkManager.cpp	/^std::vector<GLfloat> *ChunkManager::normals;$/;"	m	class:ChunkManager	file:
normals	systems/ChunkManager.hpp	/^		static std::vector<GLfloat> *normals;$/;"	m	class:ChunkManager
numPoints	dc/qef.h	/^        int numPoints;$/;"	m	class:svd::QefData
off	dc/svd.cpp	/^    float MatUtils::off(const Mat3 &a)$/;"	f	class:svd::MatUtils
off	dc/svd.cpp	/^    float MatUtils::off(const SMat3 &a)$/;"	f	class:svd::MatUtils
operator <<	dc/qef.cpp	/^    std::ostream &operator<<(std::ostream &os, const QefData &qef)$/;"	f	namespace:svd
operator <<	dc/svd.cpp	/^    std::ostream &operator<<(std::ostream &os, const Mat3 &m)$/;"	f	namespace:svd
operator <<	dc/svd.cpp	/^    std::ostream &operator<<(std::ostream &os, const SMat3 &m)$/;"	f	namespace:svd
operator <<	dc/svd.cpp	/^    std::ostream &operator<<(std::ostream &os, const Vec3 &v)$/;"	f	namespace:svd
operator =	dc/qef.cpp	/^	QefData& QefData::operator=(const QefData& rhs)$/;"	f	class:svd::QefData
pinv	dc/svd.cpp	/^    static float pinv(const float x, const float tol)$/;"	f	namespace:svd
position	common/controls.cpp	/^glm::vec3 position = glm::vec3( 0, 0, -5 );$/;"	v
position	dc/octree.hpp	/^		vec3 position;$/;"	m	class:Octree
position	dc/octree.hpp	/^	vec3			position;$/;"	m	struct:Vertex
position	systems/chunk.hpp	/^		vec3 position;$/;"	m	class:Chunk
processEdgeMask	dc/octree.cpp	/^const int processEdgeMask[3][4] = {{3,2,1,0},{7,5,6,4},{11,10,9,8}} ;$/;"	v
pseudoinverse	dc/svd.cpp	/^    void Svd::pseudoinverse(Mat3 &out, const SMat3 &d, const Mat3 &v,$/;"	f	class:svd::Svd
qef	dc/octree.hpp	/^	svd::QefData	qef;$/;"	m	struct:Vertex
reset	dc/qef.cpp	/^    void QefSolver::reset()$/;"	f	class:svd::QefSolver
root	systems/chunk.hpp	/^		Octree* root;$/;"	m	class:Chunk
rot01	dc/svd.cpp	/^    void Schur2::rot01(SMat3 &m, float &c, float &s)$/;"	f	class:svd::Schur2
rot01_post	dc/svd.cpp	/^    void Givens::rot01_post(Mat3 &m, const float c, const float s)$/;"	f	class:svd::Givens
rot02	dc/svd.cpp	/^    void Schur2::rot02(SMat3 &m, float &c, float &s)$/;"	f	class:svd::Schur2
rot02_post	dc/svd.cpp	/^    void Givens::rot02_post(Mat3 &m, const float c, const float s)$/;"	f	class:svd::Givens
rot12	dc/svd.cpp	/^    void Schur2::rot12(SMat3 &m, float &c, float &s)$/;"	f	class:svd::Schur2
rot12_post	dc/svd.cpp	/^    void Givens::rot12_post(Mat3 &m, const float c, const float s)$/;"	f	class:svd::Givens
rotate01	dc/svd.cpp	/^    static void rotate01(SMat3 &vtav, Mat3 &v)$/;"	f	namespace:svd
rotate02	dc/svd.cpp	/^    static void rotate02(SMat3 &vtav, Mat3 &v)$/;"	f	namespace:svd
rotate12	dc/svd.cpp	/^    static void rotate12(SMat3 &vtav, Mat3 &v)$/;"	f	namespace:svd
scale	dc/svd.cpp	/^    void VecUtils::scale(Vec3 &v, const float s)$/;"	f	class:svd::VecUtils
seam	systems/chunk.hpp	/^		Octree* seam = nullptr;$/;"	m	class:Chunk
seed	dc/octree.cpp	/^int Octree::seed = 0;$/;"	m	class:Octree	file:
seed	dc/octree.hpp	/^		static int seed;$/;"	m	class:Octree
set	dc/qef.cpp	/^    void QefData::set(const QefData &rhs)$/;"	f	class:svd::QefData
set	dc/qef.cpp	/^    void QefData::set(const float ata_00, const float ata_01,$/;"	f	class:svd::QefData
set	dc/svd.cpp	/^    void Mat3::set(const Mat3 &rhs)$/;"	f	class:svd::Mat3
set	dc/svd.cpp	/^    void Mat3::set(const float m00, const float m01, const float m02,$/;"	f	class:svd::Mat3
set	dc/svd.cpp	/^    void Vec3::set(const Vec3 &rhs)$/;"	f	class:svd::Vec3
set	dc/svd.cpp	/^    void Vec3::set(const float x, const float y, const float z)$/;"	f	class:svd::Vec3
setAta	dc/qef.cpp	/^    void QefSolver::setAta()$/;"	f	class:svd::QefSolver
setAtb	dc/qef.cpp	/^    void QefSolver::setAtb()$/;"	f	class:svd::QefSolver
setSDF	dc/octree.cpp	/^void setSDF() {$/;"	f
setSymmetric	dc/svd.cpp	/^    void Mat3::setSymmetric(const SMat3 &rhs)$/;"	f	class:svd::Mat3
setSymmetric	dc/svd.cpp	/^    void Mat3::setSymmetric(const float a00, const float a01, const float a02,$/;"	f	class:svd::Mat3
setSymmetric	dc/svd.cpp	/^    void SMat3::setSymmetric(const SMat3 &rhs)$/;"	f	class:svd::SMat3
setSymmetric	dc/svd.cpp	/^    void SMat3::setSymmetric(const float a00, const float a01, const float a02,$/;"	f	class:svd::SMat3
shadeProgramID	main.cpp	/^GLuint shadeProgramID;$/;"	v
showBounds	main.cpp	/^bool showBounds = false;$/;"	v
size	dc/octree.hpp	/^		float size;$/;"	m	class:Octree
solve	dc/qef.cpp	/^    float QefSolver::solve(Vec3 &outx, const float svd_tol,$/;"	f	class:svd::QefSolver
solveLeastSquares	dc/svd.cpp	/^    LeastSquares::solveLeastSquares(const Mat3 &a, const Vec3 &b, Vec3 &x,$/;"	f	class:svd::LeastSquares
solveSymmetric	dc/svd.cpp	/^    float Svd::solveSymmetric(const SMat3 &A, const Vec3 &b, Vec3 &x,$/;"	f	class:svd::Svd
speed	common/controls.cpp	/^float speed = 3.0f; \/\/ 3 units \/ second$/;"	v
sub	dc/svd.cpp	/^    void VecUtils::sub(Vec3 &c, const Vec3 &a, const Vec3 &b)$/;"	f	class:svd::VecUtils
svd	dc/qef.cpp	/^namespace svd$/;"	n	file:
svd	dc/qef.h	/^namespace svd$/;"	n
svd	dc/svd.cpp	/^namespace svd$/;"	n	file:
svd	dc/svd.h	/^namespace svd$/;"	n
test	common/controls.cpp	/^bool test = false;$/;"	v
testModule	dc/octree.cpp	/^module::Perlin testModule;$/;"	v
transpose	dc/svd.cpp	/^    void MatUtils::transpose(Mat3 &out, const Mat3 &a)$/;"	f	class:svd::MatUtils
type	dc/octree.hpp	/^		OctreeNodeType	type;$/;"	m	class:Octree
update	engine.cpp	/^void Engine::update() {$/;"	f	class:Engine
vertMap	dc/octree.cpp	/^const int vertMap[8][3] =$/;"	v
vertex	dc/octree.hpp	/^		Vertex* vertex;$/;"	m	class:Octree
verticalAngle	common/controls.cpp	/^float verticalAngle = 0.0f;$/;"	v
vertices	main.cpp	/^std::vector<GLfloat> vertices;$/;"	v
vertices	systems/ChunkManager.hpp	/^		static std::vector<GLfloat> *vertices;$/;"	m	class:ChunkManager
vmul	dc/svd.cpp	/^    void MatUtils::vmul(Vec3 &out, const Mat3 &a, const Vec3 &v)$/;"	f	class:svd::MatUtils
vmul_symmetric	dc/svd.cpp	/^    void MatUtils::vmul_symmetric(Vec3 &out, const SMat3 &a, const Vec3 &v)$/;"	f	class:svd::MatUtils
window	main.cpp	/^GLFWwindow* window;$/;"	v
wireProgramID	main.cpp	/^GLuint wireProgramID;$/;"	v
x	dc/qef.h	/^        Vec3 atb, massPoint, x;$/;"	m	class:svd::QefSolver
x	dc/svd.h	/^        float x, y, z;$/;"	m	class:svd::Vec3
y	dc/svd.h	/^        float x, y, z;$/;"	m	class:svd::Vec3
z	dc/svd.h	/^        float x, y, z;$/;"	m	class:svd::Vec3
